#!/usr/bin/guile -s
!#

(define line-number 0)					;line number for error reporting
(define first-character #t)				;are we processing the first character of the line?
							;if we are and it is a macro and nothing else exists
							;on the line then we'll remove the following newline

(define parameters					;alist of parameters that is extended as 
 '()) 							;parameters are added

(define finish-hooks					;list of functions to call when the end of the
  '())							;file is reached

(define (useage)
  (display "Usage:\t lips < input.txt > output.txt | lips input.txt output.txt\n")
  (exit 1))

(define (main)
  (let* ((args (command-line))
	(argc (length args))
	(config (string-append (getenv "HOME") "/.config/lipsrc.scm")))
    (load config)
    (cond
      ((= argc 3) (set-current-input-port (open-file (list-ref args 1) "r"))
		  (set-current-output-port (open-file (list-ref args 2) "w")))
      ((= argc 1))
      (else (useage)))
    (process (current-input-port) (current-output-port))
    (close-port (current-output-port))
    (close-port (current-input-port))))

(define (include file)
  (let ((fport (open-file file "r")))
    (if fport
      (do ((c (read-char fport) (read-char fport)))
	((eof-object? c) (close-port fport))
	(display c (current-output-port))))))

(define (add-finish-hook hook)
  (set! finish-hooks (append finish-hooks (list hook))))

(define (call-finish-hooks)
  (map (lambda (hook)
	 (let ((output (hook)))
	   (if (printable? output)
	     (display output)))) finish-hooks))

(define (define-parameter sym expr)
  (set! parameters (assq-set! parameters sym expr)))

(define (printable? s)
  (or (number? s)
      (string? s)
      (list?   s)))

(define (process iport oport)
  (let loop ((cic ;current input character		;we're going to loop over all the characters
	       	 (read-char iport)))			; in the file looking for escapes
      (cond 
	((eq? cic #\~)						;if we find a tilda
		(if (eq? (peek-char iport) #\~) 		;then check if the next character is a tilda
		  (begin					;if it is we output a tilda and eat the next tilda
		    (display "~" oport)
		    (read-char iport))
		  (let ((expr (read iport)))			;else, read in the next valid lisp expression
		    (cond 					
		      						;if expr is a list then evaluate and print output
								;if we're at the beginning of a line and the character
								;following the expression is a newline then, if the expression
								;doesn't evaluate to something printable, ignore the newline
		      ((list? expr) (let ((output (primitive-eval expr))) 
				      (if (printable? output)
					(display output oport)
					(if (and first-character
					      (eq? (peek-char iport) #\newline))
					  (read-char iport)))))
		      						;if expr is a symbol then look it up in the
								;parameters alist
		      ((symbol? expr) (let ((value (assq-ref parameters expr)))
					(if value
					  (display value oport)
					  (error "No defined parameter: line:" line-number  expr))))

		      (else		(display expr oport))))))

	((eq? cic #\newline)					
		(display cic oport)
		(set! first-character #t)
		(set! line-number (1+ line-number)))

	((eof-object? cic))

	(else
	 	(if first-character 
		  (set! first-character #f))
	  	(display cic oport)))

      (if (eof-object? cic)
	(call-finish-hooks)
      (loop (read-char iport)))))

(main)

